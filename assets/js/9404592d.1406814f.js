"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[38344],{27188:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>o});var s=t(74848),r=t(28453);const a={sidebar_label:"swarm_agent",title:"agentchat.contrib.swarm_agent"},i=void 0,l={id:"reference/agentchat/contrib/swarm_agent",title:"agentchat.contrib.swarm_agent",description:"initiate\\swarm\\chat",source:"@site/docs/reference/agentchat/contrib/swarm_agent.md",sourceDirName:"reference/agentchat/contrib",slug:"/reference/agentchat/contrib/swarm_agent",permalink:"/ag2/docs/reference/agentchat/contrib/swarm_agent",draft:!1,unlisted:!1,editUrl:"https://github.com/ag2ai/ag2/edit/main/website/docs/reference/agentchat/contrib/swarm_agent.md",tags:[],version:"current",frontMatter:{sidebar_label:"swarm_agent",title:"agentchat.contrib.swarm_agent"},sidebar:"referenceSideBar",previous:{title:"society_of_mind_agent",permalink:"/ag2/docs/reference/agentchat/contrib/society_of_mind_agent"},next:{title:"text_analyzer_agent",permalink:"/ag2/docs/reference/agentchat/contrib/text_analyzer_agent"}},c={},o=[{value:"initiate_swarm_chat",id:"initiate_swarm_chat",level:3},{value:"SwarmResult",id:"swarmresult",level:2},{value:"SwarmAgent",id:"swarmagent",level:2},{value:"register_update_agent_state_before_reply",id:"register_update_agent_state_before_reply",level:3},{value:"register_hand_off",id:"register_hand_off",level:3},{value:"generate_swarm_tool_reply",id:"generate_swarm_tool_reply",level:3},{value:"add_single_function",id:"add_single_function",level:3},{value:"process_nested_chat_carryover",id:"process_nested_chat_carryover",level:3}];function d(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h3,{id:"initiate_swarm_chat",children:"initiate_swarm_chat"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def initiate_swarm_chat(\n    initial_agent: "SwarmAgent",\n    messages: Union[List[Dict[str, Any]], str],\n    agents: List["SwarmAgent"],\n    user_agent: Optional[UserProxyAgent] = None,\n    max_rounds: int = 20,\n    context_variables: Optional[Dict[str, Any]] = None,\n    after_work: Optional[Union[AFTER_WORK, Callable]] = AFTER_WORK(\n        AfterWorkOption.TERMINATE)\n) -> Tuple[ChatResult, Dict[str, Any], "SwarmAgent"]\n'})}),"\n",(0,s.jsx)(n.p,{children:"Initialize and run a swarm chat"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"initial_agent"})," - The first receiving agent of the conversation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"messages"})," - Initial message(s)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"agents"})," - List of swarm agents."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"user_agent"})," - Optional user proxy agent for falling back to."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"max_rounds"})," - Maximum number of conversation rounds."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"context_variables"})," - Starting context variables."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"after_work"})," - Method to handle conversation continuation when an agent doesn't select the next agent. If no agent is selected and no tool calls are output, we will use this method to determine the next agent.\nMust be a AFTER_WORK instance (which is a dataclass accepting a SwarmAgent, AfterWorkOption, A str (of the AfterWorkOption)) or a callable.\nAfterWorkOption:\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"TERMINATE (Default): Terminate the conversation."}),"\n",(0,s.jsx)(n.li,{children:"REVERT_TO_USER : Revert to the user agent if a user agent is provided. If not provided, terminate the conversation."}),"\n",(0,s.jsx)(n.li,{children:"STAY : Stay with the last speaker."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Callable"})," - A custom function that takes the current agent, messages, groupchat, and context_variables as arguments and returns the next agent. The function should return None to terminate.\n",(0,s.jsx)(n.code,{children:"python           def custom_afterwork_func(last_speaker: SwarmAgent, messages: List[Dict[str, Any]], groupchat: GroupChat, context_variables: Optional[Dict[str, Any]]) -> Optional[SwarmAgent]:           "})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ChatResult"})," - Conversations chat history.\nDict[str, Any]: Updated Context variables."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"SwarmAgent"})," - Last speaker."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"swarmresult",children:"SwarmResult"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class SwarmResult(BaseModel)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Encapsulates the possible return values for a swarm agent function."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"values"})," ",(0,s.jsx)(n.em,{children:"str"})," - The result values as a string."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"agent"})," ",(0,s.jsx)(n.em,{children:"SwarmAgent"})," - The swarm agent instance, if applicable."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"context_variables"})," ",(0,s.jsx)(n.em,{children:"dict"})," - A dictionary of context variables."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"swarmagent",children:"SwarmAgent"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class SwarmAgent(ConversableAgent)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Swarm agent for participating in a swarm."}),"\n",(0,s.jsx)(n.p,{children:"SwarmAgent is a subclass of ConversableAgent."}),"\n",(0,s.jsx)(n.p,{children:"Additional args:\nfunctions (List[Callable]): A list of functions to register with the agent."}),"\n",(0,s.jsx)(n.h3,{id:"register_update_agent_state_before_reply",children:"register_update_agent_state_before_reply"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def register_update_agent_state_before_reply(\n        functions: Optional[Union[List[Callable], Callable]])\n"})}),"\n",(0,s.jsx)(n.p,{children:"Register functions that will be called when the agent is selected and before it speaks.\nYou can add your own validation or precondition functions here."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"functions"})," ",(0,s.jsx)(n.em,{children:"List[Callable[[], None]]"})," - A list of functions to be registered. Each function\nis called when the agent is selected and before it speaks."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"register_hand_off",children:"register_hand_off"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def register_hand_off(hand_to: Union[List[Union[ON_CONDITION, AFTER_WORK]],\n                                     ON_CONDITION, AFTER_WORK])\n"})}),"\n",(0,s.jsx)(n.p,{children:"Register a function to hand off to another agent."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"hand_to"})," - A list of ON_CONDITIONs and an, optional, AFTER_WORK condition"]}),"\n",(0,s.jsx)(n.p,{children:"Hand off template:\ndef transfer_to_agent_name() -> SwarmAgent:\nreturn agent_name"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"register the function with the agent"}),"\n",(0,s.jsx)(n.li,{children:"register the schema with the agent, description set to the condition"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"generate_swarm_tool_reply",children:"generate_swarm_tool_reply"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def generate_swarm_tool_reply(\n        messages: Optional[List[Dict]] = None,\n        sender: Optional[Agent] = None,\n        config: Optional[OpenAIWrapper] = None) -> Tuple[bool, dict]\n"})}),"\n",(0,s.jsx)(n.p,{children:"Pre-processes and generates tool call replies."}),"\n",(0,s.jsx)(n.p,{children:"This function:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Adds context_variables back to the tool call for the function, if necessary."}),"\n",(0,s.jsx)(n.li,{children:"Generates the tool calls reply."}),"\n",(0,s.jsx)(n.li,{children:"Updates context_variables and next_agent based on the tool call response."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"add_single_function",children:"add_single_function"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def add_single_function(func: Callable, name=None, description="")\n'})}),"\n",(0,s.jsx)(n.p,{children:"Add a single function to the agent, removing context variables for LLM use"}),"\n",(0,s.jsx)(n.h3,{id:"process_nested_chat_carryover",children:"process_nested_chat_carryover"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"@staticmethod\ndef process_nested_chat_carryover(chat: Dict[str, Any],\n                                  recipient: ConversableAgent,\n                                  messages: List[Dict[str, Any]],\n                                  sender: ConversableAgent,\n                                  trim_n_messages: int = 0) -> None\n"})}),"\n",(0,s.jsx)(n.p,{children:"Process carryover messages for a nested chat (typically for the first chat of a swarm)"}),"\n",(0,s.jsx)(n.p,{children:'The carryover_config key is a dictionary containing:\n"summary_method": The method to use to summarise the messages, can be "all", "last_msg", "reflection_with_llm" or a Callable\n"summary_args": Optional arguments for the summary method'}),"\n",(0,s.jsx)(n.p,{children:'Supported carryover \'summary_methods\' are:\n"all" - all messages will be incorporated\n"last_msg" - the last message will be incorporated\n"reflection_with_llm" - an llm will summarise all the messages and the summary will be incorporated as a single message\nCallable - a callable with the signature: my_method(agent: ConversableAgent, messages: List[Dict[str, Any]]) -> str'}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"chat"})," - The chat dictionary containing the carryover configuration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"recipient"})," - The recipient agent"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"messages"})," - The messages from the parent chat"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sender"})," - The sender agent"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"trim_n_messages"})," - The number of latest messages to trim from the messages list"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var s=t(96540);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);